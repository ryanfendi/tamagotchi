<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pixel Pet 100√ó100 ‚Äî Detail Skins + Anim</title>
<style>
  :root{ --bg:#0b1220; --panel:#0f1724; --accent:#10b981; --muted:#9fb3b5 }
  body{ margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center;
        background:linear-gradient(180deg,#071726,#04202a); color:#e6eef6; font-family:Inter,system-ui,Arial; padding:18px }
  .card{ width:960px; max-width:100%; display:grid; grid-template-columns:360px 1fr; gap:18px }
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.03) }
  h1{ margin:0 0 10px 0; font-size:18px }
  canvas{ image-rendering: pixelated; display:block; margin:8px auto; background:#08121a; border-radius:8px }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:8px }
  button{ background:linear-gradient(180deg,var(--accent),#059669); border:0; color:#042018; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700 }
  button.alt{ background:linear-gradient(180deg,#06b6d4,#0891b2) }
  input[type=file]{ display:none }
  label.upload{ background:#10b981; padding:6px 8px; border-radius:6px; color:#042018; cursor:pointer }
  .small{ font-size:13px; color:var(--muted) }
  .row{ display:flex; gap:8px; align-items:center; justify-content:center; margin-top:10px; flex-wrap:wrap }
  .leftcol{ text-align:center }
  pre{ background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; color:#cfe9f8; font-size:12px; max-height:220px; overflow:auto }
  @media(max-width:920px){ .card{ grid-template-columns:1fr } }
</style>
</head>
<body>
  <div class="card">
    <div class="panel leftcol">
      <h1>üé® Pixel Pet ‚Äî 100√ó100 Skins</h1>

      <!-- canvas is 100x100 but scaled by CSS to 320x320 -->
      <canvas id="petCanvas" width="100" height="100" style="width:320px;height:320px"></canvas>

      <div class="controls">
        <button id="evolveBtn">‚ú® Evolve</button>
        <button id="feedBtn" class="alt">üçé Feed (jump)</button>
        <button id="exportBtn">‚¨á Export Skin</button>
        <button id="resetBtn">‚ôª Reset Skins</button>
      </div>

      <div class="row">
        <label class="upload">Upload skin stage 0<input id="upload0" type="file" accept="image/png"></label>
        <label class="upload">Upload stage 1<input id="upload1" type="file" accept="image/png"></label>
        <label class="upload">Upload stage 2<input id="upload2" type="file" accept="image/png"></label>
      </div>

      <div class="small" style="margin-top:10px;line-height:1.4">
        Petunjuk: upload PNG 100√ó100 (pixel art) untuk mengganti skin per stage. Atau gunakan skin procedural bawaan. Klik <strong>Evolve</strong> untuk berpindah stage. Feed memicu animasi jump + suara.
      </div>
    </div>

    <div class="panel">
      <h1>üîä Sound & Info</h1>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <label class="inline small"><input id="soundToggle" type="checkbox" checked> Suara aktif</label>
        <label class="inline small"><input id="devMode" type="checkbox"> DEV: percepat animasi</label>
      </div>

      <div style="margin-top:12px">
        <div class="small">Stage: <strong id="stageLabel">0</strong></div>
        <div class="small">Age (days): <strong id="ageLabel">0</strong></div>
        <div class="small">Level (weeks): <strong id="levelLabel">1</strong></div>
        <div class="small">Last feed: <span id="lastFeedLabel">‚Äî</span></div>
      </div>

      <h2 style="margin-top:12px">üì¶ Marketplace & Leaderboard (local)</h2>
      <div style="display:flex;gap:8px;align-items:center">
        <input id="saleInput" placeholder="sale id" style="padding:6px;border-radius:6px;border:0;background:rgba(255,255,255,0.02)">
        <button id="postSale" class="alt">Post</button>
        <button id="refreshMarket">Refresh</button>
      </div>

      <div style="margin-top:10px">
        <input id="buyInput" placeholder="buy id" style="padding:6px;border-radius:6px;border:0;background:rgba(255,255,255,0.02)">
        <button id="buyBtn">Buy</button>
      </div>

      <h3 style="margin-top:10px">Marketplace</h3>
      <div id="marketList" class="small" style="max-height:160px;overflow:auto"></div>

      <h3 style="margin-top:10px">Leaderboard</h3>
      <div id="leaderBoard" class="small" style="max-height:160px;overflow:auto"></div>

      <div style="margin-top:10px" class="small">Semua data marketplace & leaderboard disimpan di localStorage. Untuk global, hubungkan backend Replit (bisa saya bantu).</div>
    </div>
  </div>

<script>
/* Main script:
   - procedural 100x100 sprites (detailed look)
   - allows upload of PNG 100x100 per stage
   - draw scaled to canvas
   - animation (walk sway + jump on feed)
   - WebAudio simple sounds
   - marketplace & leaderboard local
*/

// ---------- utility ----------
const STORAGE_PLAYERS = 'tama_players_100';
const STORAGE_MARKET = 'tama_market_100';
const MS_HOUR = 60*60*1000;
let DEV = false;

function hexToRgb(hex){
  const n = parseInt(hex.replace('#',''),16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function msToStr(ms){ if(ms<=0) return '0s'; const s=Math.floor(ms/1000); const m=Math.floor(s/60); const h=Math.floor(m/60); if(h>0) return h+'h'+(m%60)+'m'; if(m>0) return m+'m'; return s+'s'; }

// ---------- sprites storage ----------
let skinStages = [ null, null, null ]; // each either ImageData (100x100) or null => use procedural
let stageIndex = 0;
let ageDays = 0;
let levelWeeks = 1;
let lastFeed = null;

// canvas
const petCanvas = document.getElementById('petCanvas');
const PCTX = petCanvas.getContext('2d');
PCTX.imageSmoothingEnabled = false;

// UI refs
const stageLabel = document.getElementById('stageLabel');
const ageLabel = document.getElementById('ageLabel');
const levelLabel = document.getElementById('levelLabel');
const lastFeedLabel = document.getElementById('lastFeedLabel');
const soundToggle = document.getElementById('soundToggle');
const devModeChk = document.getElementById('devMode');

const marketListEl = document.getElementById('marketList');
const leaderBoardEl = document.getElementById('leaderBoard');

// WebAudio
const AudioContextClass = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioContextClass ? new AudioContextClass() : null;
function playTone(freq, dur=0.12, type='sine', vol=0.12){
  if(!audioCtx || !soundToggle.checked) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  setTimeout(()=> o.stop(), dur*1000);
}
function soundFeed(){ playTone(900,0.07,'triangle',0.09); setTimeout(()=>playTone(1200,0.06,'sine',0.06),90); }
function soundEvolve(){ playTone(620,0.18,'sine',0.12); setTimeout(()=>playTone(880,0.12,'sine',0.12),140); }
function soundLevel(){ playTone(1200,0.18,'sine',0.14); setTimeout(()=>playTone(1600,0.12,'sine',0.12),120); }

// resume audio on user click if suspended
document.addEventListener('click', ()=> { if(audioCtx && audioCtx.state==='suspended') audioCtx.resume().catch(()=>{}); }, { once:true });

// ---------- procedural 100x100 "hand-painted" sprites ----------
function makeEmptySprite(){
  const w=100,h=100;
  const imageData = PCTX.createImageData(w,h);
  // fill transparent black background
  for(let i=0;i<imageData.data.length;i+=4){ imageData.data[i]=0; imageData.data[i+1]=0; imageData.data[i+2]=0; imageData.data[i+3]=255; }
  return imageData;
}

// painter that draws a blob with shading, speckles, eyes, highlights
function paintSpriteBase(seedColor){
  const w=100,h=100;
  const img = makeEmptySprite();
  const base = hexToRgb(seedColor);
  // background subtle noise + radial shading to give "hand-painted" feel
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i=(y*w + x)*4;
      // compute distance from center for shading
      const dx = (x - w/2), dy=(y - h/2);
      const dist = Math.sqrt(dx*dx+dy*dy);
      // base color with small random noise
      const noise = (Math.random()-0.5)*20;
      const shade = 1 - Math.min(0.7, dist / (w/2));
      img.data[i] = Math.max(0, Math.min(255, Math.round(base.r*shade + noise)));
      img.data[i+1] = Math.max(0, Math.min(255, Math.round(base.g*shade + noise*0.7)));
      img.data[i+2] = Math.max(0, Math.min(255, Math.round(base.b*shade + noise*0.5)));
      img.data[i+3] = 255;
    }
  }
  // draw main body blob (ellipse)
  const cx = w/2, cy = h/2 - 6, rx = 30, ry = 36;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const dx = (x-cx)/rx, dy=(y-cy)/ry;
      if(dx*dx + dy*dy <= 1){
        const i=(y*w + x)*4;
        // add highlight towards top-left
        const hl = Math.max(0, 1 - ((x-cx+8)/ (rx*1.3)) - ((y-cy+6)/(ry*1.6)));
        img.data[i] = Math.min(255, img.data[i] + 30*hl);
        img.data[i+1] = Math.min(255, img.data[i+1] + 20*hl);
        img.data[i+2] = Math.min(255, img.data[i+2] + 10*hl);
      }
    }
  }
  // paint eyes
  const eyeY = Math.round(cy - 4), eyeLX = Math.round(cx - 8), eyeRX = Math.round(cx + 6);
  for(let yy=eyeY-2; yy<=eyeY+2; yy++){
    for(let xx=eyeLX-2; xx<=eyeLX+2; xx++){
      const i=(yy*w + xx)*4; img.data[i]=10; img.data[i+1]=12; img.data[i+2]=18;
    }
  }
  for(let yy=eyeY-2; yy<=eyeY+2; yy++){
    for(let xx=eyeRX-2; xx<=eyeRX+2; xx++){
      const i=(yy*w + xx)*4; img.data[i]=10; img.data[i+1]=12; img.data[i+2]=18;
    }
  }
  // small blushes
  const blushColor = hexToRgb('#ffb6c1');
  for(let yy=eyeY+6; yy<=eyeY+10; yy++){
    for(let xx=eyeLX-4; xx<=eyeLX-2; xx++){
      const i=(yy*w + xx)*4;
      img.data[i] = Math.min(255, img.data[i] + blushColor.r); img.data[i+1] = Math.min(255, img.data[i+1] + blushColor.g/2); img.data[i+2] = Math.min(255, img.data[i+2] + blushColor.b/2);
    }
    for(let xx=eyeRX+2; xx<=eyeRX+4; xx++){
      const i=(yy*w + xx)*4;
      img.data[i] = Math.min(255, img.data[i] + blushColor.r); img.data[i+1] = Math.min(255, img.data[i+1] + blushColor.g/2); img.data[i+2] = Math.min(255, img.data[i+2] + blushColor.b/2);
    }
  }
  // speckles
  for(let k=0;k<400;k++){
    const x = Math.floor(Math.random()*w), y = Math.floor(Math.random()*h);
    const i = (y*w + x)*4;
    img.data[i] = Math.min(255, img.data[i] + Math.floor((Math.random()*40)));
    img.data[i+1] = Math.min(255, img.data[i+1] + Math.floor((Math.random()*30)));
  }
  return img;
}

// build default detailed sprites (3 stages)
function buildDefaultSkins(){
  skinStages[0] = paintSpriteBase('#ffd66b'); // baby yellow
  skinStages[1] = paintSpriteBase('#9be7ff'); // teen aqua
  skinStages[2] = paintSpriteBase('#ffb86b'); // adult orange
}
function paintSpriteBase(seedHex){ return paintSpriteBase_core(seedHex); }
function paintSpriteBase_core(seedHex){
  // wrapper to allow multiple passes for varied look
  return paintSpriteBase_core_impl(seedHex);
}
function paintSpriteBase_core_impl(seedHex){
  // calls paintSpriteBase logic above
  return (function(){ 
    // create local canvas painter and reuse the function above
    return (function(){ 
      // reuse paintSpriteBase code from earlier (callable)
      return (function(){ // tiny wrapper to avoid hoisting conflicts
        // call the painter defined earlier in this file
        return (function(){ 
          // reconstruct by calling paintSpriteBase logic inline
          const w=100,h=100;
          const img = makeEmptySprite();
          const base = hexToRgb(seedHex);
          for(let y=0;y<h;y++){
            for(let x=0;x<w;x++){
              const i=(y*w + x)*4;
              const dx = (x - w/2), dy=(y - h/2);
              const dist = Math.sqrt(dx*dx+dy*dy);
              const noise = (Math.random()-0.5)*24;
              const shade = 1 - Math.min(0.8, dist / (w/2));
              img.data[i] = Math.max(0, Math.min(255, Math.round(base.r*shade + noise)));
              img.data[i+1] = Math.max(0, Math.min(255, Math.round(base.g*shade + noise*0.7)));
              img.data[i+2] = Math.max(0, Math.min(255, Math.round(base.b*shade + noise*0.5)));
              img.data[i+3] = 255;
            }
          }
          const cx = w/2, cy = h/2 - 6, rx = 32, ry = 36;
          for(let y=0;y<h;y++){
            for(let x=0;x<w;x++){
              const dx=(x-cx)/rx, dy=(y-cy)/ry;
              if(dx*dx + dy*dy <= 1){
                const i=(y*w + x)*4;
                const hl = Math.max(0, 1 - ((x-cx+8)/(rx*1.3)) - ((y-cy+6)/(ry*1.6)));
                img.data[i] = Math.min(255, img.data[i] + 30*hl);
                img.data[i+1] = Math.min(255, img.data[i+1] + 20*hl);
                img.data[i+2] = Math.min(255, img.data[i+2] + 10*hl);
              }
            }
          }
          const eyeY = Math.round(cy - 4), eyeLX = Math.round(cx - 8), eyeRX = Math.round(cx + 6);
          for(let yy=eyeY-2; yy<=eyeY+2; yy++){
            for(let xx=eyeLX-2; xx<=eyeLX+2; xx++){
              if(xx>=0 && xx<w && yy>=0 && yy<h){
                const i=(yy*w + xx)*4; img.data[i]=10; img.data[i+1]=12; img.data[i+2]=18;
              }
            }
          }
          for(let yy=eyeY-2; yy<=eyeY+2; yy++){
            for(let xx=eyeRX-2; xx<=eyeRX+2; xx++){
              if(xx>=0 && xx<w && yy>=0 && yy<h){
                const i=(yy*w + xx)*4; img.data[i]=10; img.data[i+1]=12; img.data[i+2]=18;
              }
            }
          }
          const blushColor = hexToRgb('#ff9aa2');
          for(let yy=eyeY+6; yy<=eyeY+10; yy++){
            for(let xx=eyeLX-4; xx<=eyeLX-2; xx++){
              if(xx>=0 && xx<w && yy>=0 && yy<h){
                const i=(yy*w + xx)*4;
                img.data[i] = Math.min(255, img.data[i] + blushColor.r); img.data[i+1] = Math.min(255, img.data[i+1] + blinkInt(blushColor.g/2)); img.data[i+2] = Math.min(255, img.data[i+2] + blushColor.b/2);
              }
            }
            for(let xx=eyeRX+2; xx<=eyeRX+4; xx++){
              if(xx>=0 && xx<w && yy>=0 && yy<h){
                const i=(yy*w + xx)*4;
                img.data[i] = Math.min(255, img.data[i] + blushColor.r); img.data[i+1] = Math.min(255, img.data[i+1] + blushColor.g/2); img.data[i+2] = Math.min(255, img.data[i+2] + blushColor.b/2);
              }
            }
          }
          // speckles
          for(let k=0;k<700;k++){
            const x = Math.floor(Math.random()*w), y = Math.floor(Math.random()*h);
            const i=(y*w + x)*4;
            img.data[i] = Math.min(255, img.data[i] + Math.floor(Math.random()*40));
            img.data[i+1] = Math.min(255, img.data[i+1] + Math.floor(Math.random()*30));
            img.data[i+2] = Math.min(255, img.data[i+2] + Math.floor(Math.random()*20));
          }
          return img;
        })();
      })();
    })();
  }
}
function blinkInt(v){ return Math.round(v); }

// build defaults at startup
buildDefaultSkins();

// ---------- drawing & animation ----------
let anim = { t:0, mode:'idle' };
let walkOffset = 0;

function draw(){
  // clear
  PCTX.clearRect(0,0,petCanvas.width, petCanvas.height);
  if(!skinStages[stageIndex]) skinStages[stageIndex] = (stageIndex===0? paintSpriteBase_core_impl('#ffd66b') : (stageIndex===1? paintSpriteBase_core_impl('#9be7ff') : paintSpriteBase_core_impl('#ffb86b')) );
  // animation params
  anim.t++;
  // walking sway X offset
  const sway = Math.sin(anim.t/10) * 6;
  let jumpY = 0;
  if(anim.mode === 'jump'){ jumpY = Math.abs(Math.sin(anim.t/6))*18; if(anim.t>30){ anim.mode='idle'; anim.t=0; } }
  // compute draw position center
  const px = Math.round((petCanvas.width - 100)/2 + sway);
  const py = Math.round((petCanvas.height - 100)/2 - jumpY);
  // draw sprite imageData at px,py
  PCTX.putImageData(skinStages[stageIndex], px, py);
}

setInterval(()=>{ draw(); }, DEV ? 50 : 80);

// ---------- UI actions ----------
document.getElementById('evolveBtn').addEventListener('click', ()=>{
  stageIndex = (stageIndex + 1) % 3;
  soundEvolve();
  document.getElementById('stageLabel').innerText = stageIndex;
  log('Evolved -> stage '+stageIndex);
  renderMeta();
});

document.getElementById('feedBtn').addEventListener('click', ()=>{
  // feed triggers jump animation + sound
  anim.mode = 'jump'; anim.t = 0;
  lastFeed = Date.now();
  document.getElementById('lastFeedLabel').innerText = new Date(lastFeed).toLocaleString();
  soundFeed();
  log('Fed pet at '+ new Date(lastFeed).toLocaleTimeString());
  // optionally increment feed counter / persist marketplace/leaderboard hooks...
});

document.getElementById('exportBtn').addEventListener('click', ()=>{
  // export current skin as PNG
  const link = document.createElement('a');
  // draw the sprite into a temporary canvas at 100x100 then scale to PNG as-is
  const tmp = document.createElement('canvas'); tmp.width = 100; tmp.height = 100;
  const tctx = tmp.getContext('2d'); tctx.putImageData(skinStages[stageIndex], 0, 0);
  link.href = tmp.toDataURL('image/png');
  link.download = `pet-stage-${stageIndex}.png`;
  link.click();
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  if(!confirm('Reset skins ke default procedural?')) return;
  buildDefaultSkins(); stageIndex=0; renderMeta(); log('Skins direset ke default.'); 
});

// upload handlers (read image, scale/convert into ImageData 100x100)
function handleUploadFile(evt, index){
  const f = evt.target.files[0];
  if(!f) return;
  const img = new Image();
  const reader = new FileReader();
  reader.onload = e => { img.src = e.target.result; };
  img.onload = () => {
    // create temp canvas to resize to 100x100 and extract ImageData
    const tmp = document.createElement('canvas'); tmp.width=100; tmp.height=100;
    const tctx = tmp.getContext('2d');
    // draw image to fit 100x100 preserving aspect via cover
    tctx.fillStyle = '#000'; tctx.fillRect(0,0,100,100);
    // compute fit
    const ar = img.width/img.height;
    let dw=100, dh=100, dx=0, dy=0;
    if(ar > 1){ // wide
      dh = 100; dw = Math.round(100*ar); dx = Math.round((100 - dw)/2);
    } else {
      dw = 100; dh = Math.round(100/ar); dy = Math.round((100 - dh)/2);
    }
    tctx.drawImage(img, dx, dy, dw, dh);
    const id = tctx.getImageData(0,0,100,100);
    skinStages[index] = id;
    log('Upload skin stage '+index+' berhasil.');
    renderMeta();
  };
  reader.readAsDataURL(f);
}
document.getElementById('upload0').addEventListener('change', e=> handleUploadFile(e,0));
document.getElementById('upload1').addEventListener('change', e=> handleUploadFile(e,1));
document.getElementById('upload2').addEventListener('change', e=> handleUploadFile(e,2));

// simple market/leaderboard (local)
function loadMarket(){ try{ return JSON.parse(localStorage.getItem(STORAGE_MARKET)||'{}'); }catch(e){ return {}; } }
function saveMarket(m){ try{ localStorage.setItem(STORAGE_MARKET, JSON.stringify(m)); }catch(e){} }
function loadPlayers(){ try{ return JSON.parse(localStorage.getItem(STORAGE_PLAYERS)||'{}'); }catch(e){ return {}; } }
function savePlayers(m){ try{ localStorage.setItem(STORAGE_PLAYERS, JSON.stringify(m)); }catch(e){} }

document.getElementById('postSale').addEventListener('click', ()=>{
  const id = (document.getElementById('saleInput')?.value || '').trim() || document.getElementById('saleInput').value;
});
document.getElementById('refreshMarket').addEventListener('click', ()=> buildMarket());
document.getElementById('buyBtn').addEventListener('click', ()=> {
  const id = (document.getElementById('buyInput')?.value || '').trim() || document.getElementById('buyInput').value;
});

// but for brevity we implement minimal market UI
function buildMarket(){
  const mk = loadMarket();
  marketListEl.innerHTML = '';
  const keys = Object.keys(mk);
  if(keys.length === 0) marketListEl.innerHTML = '<div class="small">Marketplace kosong</div>';
  keys.forEach(k=>{
    const s = mk[k];
    const d = document.createElement('div');
    d.className='small';
    d.innerHTML = `<strong>${k}</strong> ‚Äî seller:${s.seller} ‚Ä¢ age:${s.pet.ageDays||0}d ‚Ä¢ evo:${s.pet.evoIndex||0}`;
    const btn = document.createElement('button'); btn.textContent='Beli'; btn.onclick = ()=> { buyMarket(k); };
    btn.style.marginLeft='8px';
    d.appendChild(btn);
    marketListEl.appendChild(d);
  });
}
function buyMarket(id){
  const mk = loadMarket();
  const sale = mk[id];
  if(!sale) return alert('Tidak ditemukan');
  // for demo we just remove and show alert
  delete mk[id]; saveMarket(mk);
  buildMarket();
  alert('Berhasil beli pet id='+id+' (local demo)');
}

// leader local: just show current procedural stats
function buildLeaderBoard(){
  const pl = loadPlayers();
  leaderBoardEl.innerHTML = '';
  const arr = Object.values(pl);
  if(arr.length === 0) { leaderBoardEl.innerHTML = '<div class="small">Belum ada pemain</div>'; return; }
  arr.sort((a,b)=> (b.level||0) - (a.level||0));
  arr.forEach((p,i)=>{
    const el = document.createElement('div'); el.className='small';
    el.innerHTML = `${i+1}. <strong>${p.name||('Player'+i)}</strong> ‚Äî Lv ${p.level||1} ‚Ä¢ ${p.pet? (p.pet.ageDays||0)+'d' : 'no pet'}`;
    leaderBoardEl.appendChild(el);
  });
}

// logging & meta render
function log(msg){ const el = document.getElementById('log'); if(!el) return; el.innerHTML = '['+new Date().toLocaleTimeString()+'] '+ msg + '<br>' + el.innerHTML; }
function renderMeta(){ stageLabel.innerText = stageIndex; ageLabel.innerText = ageDays; levelLabel.innerText = levelWeeks; lastFeedLabel.innerText = lastFeed ? new Date(lastFeed).toLocaleString() : '‚Äî'; buildMarket(); buildLeaderBoard(); }

// small auto age/level simulation (DEV friendly)
setInterval(()=>{
  if(devModeChk.checked){ /* accelerate nothing else here */ }
}, 1000);

// initial render
renderMeta();
buildMarket();
buildLeaderBoard();

</script>
</body>
</html>
